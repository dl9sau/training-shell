Der Streameditor `sed`. Erste Schritte.
=======================================
Frank Hofmann
:subtitle:
:doctype: book
:copyright: Frank Hofmann
:revnumber: 1.1
:Author Initials: FH
:edition: 1
:lang: de
:date: 26. April 2016
:numbered:

= Vorwort =

`sed` steht für Streameditor -- ein Programm, welches einen Datenstrom
mit Hilfe von Filtern verändert. Das beinhaltet bspw. das Löschen,
Suchen und Ersetzen von Zeichenketten auf der Basis von Regulären
Ausdrücken. `sed` sieht erstmal recht einfach aus, ist aber sehr mächtig
und flexibel im Alltagsgebrauch als Filter auf der Kommandozeile und in
Shellskripten.

= Voraussetzungen zum Verständnis =

Um dieses Tutorial zu verstehen, hilft Ihnen das Basiswissen im Umgang
mit der Kommandozeile. Die Kommandos/Werkzeuge `grep`, `vi(m)` und
`less` sollten Ihnen nicht fremd sein. Alle diese Werkzeuge sind in etwa
gleich, unterscheiden sich aber mit Nuancen zueinander.

`sed` benutzt Reguläre Ausdrücke zur Beschreibung von Mustern für
Zeichenketten. Dieses Tutorial setzt grundlegende Kenntnisse von RegEx
voraus. Für ein tieferes Wissen dazu hilft Ihnen das Buch 'Reguläre
Ausdrücke' von Jeffrey Friedl <<Friedl>>.

== Struktur eines Filters ==

Prinzipiell hat ein `sed`-Filter bis zu vier Teile:

----
[Adresse]Aktion/Muster/Ersetzung/Flag
----

Jeder Teil wird durch einen `/` vom nächsten Teil separiert.

* `[Adresse]Aktion`: beschreibt die Zeilen und die Aktion, auf die das
Muster angewendet werden soll, bspw. `i` für `insert` (Zeile einfügen)
und `s` für `substitute` (suchen und ersetzen)
* `Muster`: Beschreibung des Filters als Regulärer Ausdruck (siehe dazu
die Manpage von `REGEX(7)`)
* `Ersetzung`: String, welcher den über das Muster gefundenen Suchtreffer ersetzt
* `Flag`: steuert die Aktion. Es legt fest, was passiert, wenn das Muster zutrifft.

== `sed` als Filter aufrufen ==

`sed` akzeptiert verschiedene Wege, über die es Filter entgegennimmt und
auf den Datenstrom anwendet.

=== Über `stdin` oder als direkten Parameter beim Aufruf von `sed` ===

.Filtern mittels `sed` nach einer Pipe
----
$ cat datei | sed 's/alfred/friedrich/'
----

.Filtern mittels `sed` ohne Pipe und mit direktem Aufruf der Datei
----
$ sed 's/alfred/friedrich/' datei
----

=== `sed`-Skript als separate Datei ===

Die Referenzierung erfolgt über den Schalter `-f` gefolgt von dem Dateinamen
für die Skriptdatei. GNU sed versteht auch den langen Schalter `--file`.

.Filtern mittels `sed` und dem Skript `sed.skript`
----
$ sed -f sed.skript datei
----

TIP: Bei allen Listings finden Sie in Klammern den Dateinamen des
`sed`-Beispiels. Damit können Sie das Skript sofort ausprobieren.

== Mehrere Filter miteinander kombinieren ==

Manchmal ist es einfacher, mehrere kleine Filter zu formulieren, als
sich einen einzigen, komplexen Regulären Ausdruck auszudenken. `sed`
kennt mehrere Varianten zur Verkettung der Filter. Hierbei werden die
einzelnen Anweisungen (Filter) in der Reihenfolge von `sed` verarbeitet,
wie sie im Aufruf genannt sind. 

In den nachfolgenden Beispielen wird im ersten Schritt `alfred` durch
`friedrich` ersetzt, und danach alle Vorkommen von `Holger` (mit großem
und kleinem `h`) durch `michael`. Die Ausgabe erfolgt auf `stdout`.

=== Einzelne Filter voneinander über ein Semikolon trennen ===

Im Aufruf geben Sie zwischen den Filtern ein `;` an.

.Mehrere Filter mittels `;` aneinanderreihen
----
$ sed 's/alfred/friedrich/; s/[Hh]olger/michael/' datei
----

TIP: `[Hh]` beinhaltet einen regulären Ausdruck für den einzelnen
Buchstaben `h` in Groß- oder Kleinschreibung.

=== Jeden Filter mit `-e` einleiten ===

Über den Schalter `-e` teilen Sie `sed` mit, dass ein weiterer Filter
folgt. GNU sed versteht auch den langen Schalter `--expression`.

.Mehrere Filter mittels `-e` aneinanderreihen
----
$ sed -e 's/alfred/friedrich/' -e 's/[Hh]olger/michael/' datei
----

=== Die Fähigkeiten der bash ausnutzen (mehrere Zeilen) ===

Sie können die einzelnen Filter auch über mehrere Zeilen verteilen:

.Jeden Filter in einer einzelnen Zeile
----
$ echo "apple banana" | sed -e 's/a/A/g' \
> -e 's/e/E/g'
ApplE bAnAnA
$
----

== Die Ausgabe steuern ==

Im Standardfall gibt `sed` alle Zeilen der Eingabe aus. Um das zu
unterdrücken, nutzen Sie den Schalter `-n`. Von Nutzen ist `-n`, um nur
die Zeilen der Eingabe ausgeben, in denen ihr Filter tatsächlich
Veränderungen bewirkt hat. Dazu schließen Sie den Filter mit dem Flag `p`
am Ende ab:

.Lediglich die Ersetzungen ausgeben
----
$ sed -n 's/alfred/friedrich/p' datei
----

Diese Vorgehensweise funktioniert auch bei der Aneinanderreihung von
mehreren `sed`-Skripts, selbst wenn einer der anderen Filter nicht
zutrifft.

.Veränderungen bei mehreren Filtern ausgeben
----
$ echo holger | sed -n 's/alfred/friedrich/p; s/[Hh]olger/michael/p' 
michael
$
----

== Beispiele ==

=== Ausgeben einer Datei ===

Die nachfolgenden Aufrufe haben ihre Entsprechung in den
UNIX/Linux-Kommandos `cat`, `tac`, `head` und `tail`. Das Kommando `nl`
kommt nur zum Einsatz, um eine Zeilennummer zu ergänzen und die Wirkung
des `sed`-Kommandos besser zu zeigen.

Das Ausgeben einer betreffenden Zeile erfolgt mit dem Aktionsparameter
`p` für `print`.

.Den gesamten Inhalt einfach ausgeben (`output-content.sed`)
----
$ nl logfile | sed -n 'p'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Nur die vierte Zeile ausgeben (`output-content-line4.sed`)
----
$ nl logfile | sed -n '4p'
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
$
----

.Alles außer der vierten Zeile ausgeben (`output-content-without-line4.sed`)
----
$ nl logfile | sed -n '4!p'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Nur die Zeilen vier bis sechs ausgeben (`output-content-line4-6.sed`)
----
$ nl logfile | sed -n '4,6p'
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
$
----

.Ab Zeile 7 bis zum Dateiende ausgeben (`output-content-line7-end.sed`)
----
$ nl logfile | sed -n '7,$p'
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

=== Zeilen löschen ===

Das Löschen einer betreffenden Zeile erfolgt mit dem Aktionsparameter
`d` für `delete`.

.Alle Zeilen löschen (`delete-content.sed`)
----
$ nl logfile | sed -n 'd'
$
----

.Lediglich die dritte Zeile löschen (`delete-content-line3-sed`)
----
$ nl logfile | sed '3d'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Die Zeilen 3 bis 5 löschen (`delete-content-line3-5.sed`)
----
$ nl logfile | sed '3,5d'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Nur die erste und die letzte Zeile löschen (`delete-content-first-and-last-line.sed`)
----
$ nl logfile | sed '1d;$d'
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
$
----

.Alles von der ersten Zeile bis einschließlich der Zeile löschen, die das Suchmuster `2016-01-11` beinhaltet (`delete-content-first-up-to-match.sed`)
----
$ nl logfile | sed '1,/2016-01-11/d'
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Alles bis zum Ende ab der Zeile löschen, die das Suchmuster `2016-01-11` enthält (`delete-content-match-to-the-end.sed`)
----
$ nl logfile | sed '/2016-01-11/,$d'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
$
----

.Lösche die erste Zeile nur dann, wenn diese das Suchmuster `2016-01-10` enthält (`delete-content-first-only-with-match.sed`)
----
$ nl logfile | sed '1{/2016-01-10/d;}'
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Lösche die entsprechenden Zeilen aus den Zeilen 1 bis 5 nur, wenn diese entweder das Suchmuster `2016-10-11` oder `2016-10-12` beinhalten (`delete-content-with-match.sed`)
----
$ nl logfile | sed '1,5{/2016-01-1[12]/d;}' 
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

=== Zeilen einfügen ===

==== Vor dem Suchtreffer ====

Das Anfügen von Inhalt nach einer betreffenden Zeile erfolgt mit dem
Aktionsparameter `a` für `append`. `GNU sed` versteht dafür die
einzeilige Notation `/a++++` und `/a\++++`. `BSD sed` ist pedantischer
und erwartet nach dem Aktionsparameter einen Zeilenumbruch.

.Vier `+` nach (jedem) Eintrag einfügen, der `2016-01-10` beinhaltet (`insert-after-pattern.sed`)
----
$ nl logfile | sed '/2016-01-10/a\
++++'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
++++
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

.Optische Trennung zwischen Datumswechseln (Einfügen nach dem Suchtreffer)
----
$ nl logfile | sed -e '/2016-01-10/a++++ 2016-01-11 ++++' -e '/2016-01-11/a++++ 2016-01-12 ++++'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
++++ 2016-01-11 ++++
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
++++ 2016-01-12 ++++
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
-----

Obiges Beispiel funktioniert nur mit GNU sed. Um es kompatibel für BSD
sed zu halten, bedarf es eines expliziten Umbruchs:

----
$ nl logfile | sed -e '/2016-01-10/a\
++++ 2016-01-11 ++++' -e '/2016-01-11/a\
++++ 2016-01-12 ++++'
$
----

Hierbei besteht die Gefahr, dass die Übersicht im Aufruf verloren geht.
Die Empfehlung ist, zunächst eine Musterdatei mit den beiden Suchmustern
(siehe `insert-after-with-more-patterns.sed`) zu erzeugen. Die mit `-e`
getrennten Muster/Aktionen werden in der Anweisungsdatei einfach durch
Leerzeilen voneinander getrennt.

==== Nach dem Suchtreffer ====

Das Einfügen von Inhalt vor einer betreffenden Zeile erfolgt mit dem
Aktionsparameter `i` für `insert`. `GNU sed` versteht dafür die
einzeilige Notation `/i++++` und `/i\++++`. `BSD sed` ist pedantischer
und erwartet nach dem Aktionsparameter einen Zeilenumbruch.

.Markieren aller erfolgreichen Logins des Benutzers `fho` (`insert-before-pattern.sed`)
----
$ nl logfile | sed -e '/fho logged in/i++ fho ++'
++ fho ++
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
++ fho ++
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
++ fho ++
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
     6   2016-01-12 14:45:12 login failed for user root from 10.10.17.44
     7   2016-01-12 14:46:10 login failed for user root from 10.10.17.45
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
     9   2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

=== Finde alle Zeilen der Eingabe, welches ein bestimmtes Muster beinhalten ===

Die nachfolgenden Aufrufe sind ähnlich zu `grep`, `vi`, `less`, wobei
hier die Verwandschaft der beiden Werkzeuge deutlich wird. Beachten Sie
bei der Benutzung aber die leichten syntaktischen Unterschiede. Ob sie
im Alltag zur Lösung Ihres Problems auf `grep`, `sed` oder `awk`
zurückgreifen, ist häufig eine Frage der Gewohnheit und mit welchem
Aufwand Sie das Problem lösen können.

.Alle Zeilen der Datei `logfile` ausgeben, die das Muster `fho` enthalten (`print-content.sed`)
----
$ sed -n '/fho/p' logfile
2016-01-10 10:45:15 user fho logged in on /dev/tty1
2016-01-11 08:30:10 user fho logged in on /dev/tty2
2016-01-12 08:46:45 user fho logged in on /dev/pty1
2016-01-12 12:13:10 user fho logged out from /dev/pty1
$
----

.Suche alle Zeilen, die entweder auf 44 oder 45 enden (`print-content-regex.sed`)
----
$ sed -n '/4[45]$/p' logfile
2016-01-12 14:45:12 login failed for user root from 10.10.17.44
2016-01-12 14:46:10 login failed for user root from 10.10.17.45
2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

GNU sed hat einen zusätzlichen Schalter namens `I`. Dieser steht für
'case insensitive', d.h. unabhängig von Groß- und Kleinschreibung. Damit
vereinfacht sich die Schreibweise wie folgt:

.Suche nach dem Vorkommen des Musters `banana` unabhängig von Groß- und Kleinschreibung (`print-content-case-ins.sed`)
----
$ echo "Apple Banana" | sed -n '/banana/Ip' 
Apple Banana
$
----

TIP: den Befehl `/I` gibt es nicht bei allen `sed`-Varianten.

Um nur die Zeilennummern zu erhalten, in denen das Suchmuster enthalten
ist, hilft Ihnen der Schalter `=`.

.Ausgabe der Zeilennummern der Zeilen, in denen das Muster enthalten ist (`print-match-line-numbers.sed`)
----
$ sed -n '/fho/ =' logfile
1
2
4
5
$
----

=== Suchen und Ersetzen nach einem Muster in ausgewählten Zeilen und Unterdrücken der Zeilen, die dem Muster nicht entsprechen ===

.Ersetze alle Vorkommen von `root` durch `alex` in Zeile 9 (`replace-in-line.sed`)
----
$ sed -n '9s/root/alex/p' logfile
2016-01-12 14:57:10 login failed for user alex from 10.10.17.45
$
----

.Ersetze alle Vorkommen von `root` durch `alex` ab Zeile 6 bis zum Ende (`replace-in-line-to-the-end.sed`)
----
$ sed -n '6,$s/root/alex/p' logfile
2016-01-12 14:45:12 login failed for user alex from 10.10.17.44
2016-01-12 14:46:10 login failed for user alex from 10.10.17.45
2016-01-12 14:57:10 login failed for user alex from 10.10.17.45
$
----

.Ersetze alle Vorkommen von `root` durch `alex` in den Zeilen 4 bis 7 (`replace-in-line4-7.sed`)
----
$ sed -n '4,7s/root/user/p' logfile
2016-01-12 14:45:12 login failed for user alex from 10.10.17.44
2016-01-12 14:46:10 login failed for user alex from 10.10.17.45
$
----

.Ersetze alle Vorkommen von `root` durch `alex` außerhalb der Zeilen 4 bis 7 (`replace-outside-line4-7.sed`)
----
$ nl logfile | sed -n '4,7!s/root/user/p'
     9   2016-01-12 14:57:10 login failed for user user from 10.10.17.45
$
----

.Ersetze alle Vorkommen der IP-Adresse `10.10.17.45` durch den Hostnamen `supercomputer` in allen Zeilen des Logfiles, in denen die Zeichenkette `2016-01-12` enthalten ist
----
$ nl logfile | sed -n '/2016-01-12/s/10\.10\.17\.45/supercomputer/p'
     7   2016-01-12 14:46:10 login failed for user root from supercomputer
     9   2016-01-12 14:57:10 login failed for user root from supercomputer
$
----

TIP: Beachten Sie die besondere Schreibweise von `\.`. Ein Punkt ist ein
Metacharacter im RegEx-Patternmatching und trifft auf jedes beliebige
Zeichen zu. Dank dem vorangestellten Escape-Character `\` matcht
lediglich ein echter `.`.

=== Suchen und Ersetzen nach Vorkommen ===

.Ersetze alle Vorkommen von `apple` durch `banana`
----
$ echo "apple orange melon apple" | sed 's/apple/banana/g'
banana orange melon banana
$
----

.Ersetze nur das zweite Vorkommen von `apple` durch `banana`
----
$ echo "apple orange melon apple" | sed 's/apple/banana/2'
apple orange melon banana
$
----

.Ersetze ab dem zweiten Vorkommen jedes Mal `apple` durch `banana`
----
$ echo "apple orange melon apple apple" | sed 's/apple/banana/2g'
apple orange melon banana banana
$
----

.Ersetze eine komplette Zeile
----
$ nl logfile | sed -e '/login failed/clogin failed'
     1   2016-01-10 10:45:15 user fho logged in on /dev/tty1
     2   2016-01-11 08:30:10 user fho logged in on /dev/tty2
     3   2016-01-12 08:45:12 user james logged in on /dev/tty1
     4   2016-01-12 08:46:45 user fho logged in on /dev/pty1
     5   2016-01-12 12:13:10 user fho logged out from /dev/pty1
login failed
login failed
     8   2016-01-12 14:55:05 user james logged out from /dev/tty1
login failed
$
----

=== Spaltenweise agieren ===

.Entferne die erste Spalte (Trennzeichen: `:`) in den Zeilen 1 bis 10 der Datei `/etc/passwd` (ersetze alles bis zum ersten `:` durch nichts)
----
$ sed -n '1,10s/[^:]\+://p' /etc/passwd
x:0:0:root:/root:/bin/bash
x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
x:2:2:bin:/bin:/usr/sbin/nologin
x:3:3:sys:/dev:/usr/sbin/nologin
x:4:65534:sync:/bin:/bin/sync
x:5:60:games:/usr/games:/usr/sbin/nologin
x:6:12:man:/var/cache/man:/usr/sbin/nologin
x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
x:8:8:mail:/var/mail:/usr/sbin/nologin
x:9:9:news:/var/spool/news:/usr/sbin/nologin
$
----

.Nur die erste Spalte ausgeben, Trennzeichen ist `:` (entspricht `cut -d: -f1 /etc/passwd`)
----
$ sed -n '1,10s/:.*$//p' /etc/passwd
root
daemon
bin
sys
sync
games
man
lp
mail
news
$
----

Hinweis: auf Apple Mac OSX sind die ersten 10 Zeilen der /etc/passwd mit Kommentarzeichen versehen; deshalb ist auf einem solchen System die Ausgabe dieses Beispiels leer.

.Eine weitere Spalte am Anfang hinzufügen (Inhalt: `A`)
----
$ sed -n '1,10s/.*/A:&/p' /etc/passwd
A:root:x:0:0:root:/root:/bin/bash
A:daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
A:bin:x:2:2:bin:/bin:/usr/sbin/nologin
A:sys:x:3:3:sys:/dev:/usr/sbin/nologin
A:sync:x:4:65534:sync:/bin:/bin/sync
A:games:x:5:60:games:/usr/games:/usr/sbin/nologin
A:man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
A:lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
A:mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
A:news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
$
----

Hinweis: Das Beispiel sollte die Funktionsweise von '&' näher bringen. Kuerzer waere
  $ sed -n '1,10s/^/A:/p' /etc/passwd
oder, weil ohnehin jede Zeile matcht (-n nur die matchenden, /p ausgeben), am besten
  $ sed -e 's/1,10s/^/A:/' /etc/passwd

.Eine weitere Spalte am Ende hinzufügen (Inhalt: `B`)
----
$ sed -n '1,10s/.*/&:B/p' /etc/passwd
root:x:0:0:root:/root:/bin/bash:B
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin:B
bin:x:2:2:bin:/bin:/usr/sbin/nologin:B
sys:x:3:3:sys:/dev:/usr/sbin/nologin:B
sync:x:4:65534:sync:/bin:/bin/sync:B
games:x:5:60:games:/usr/games:/usr/sbin/nologin:B
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin:B
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin:B
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin:B
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin:B
$
----

Hinweis: die einfachere Syntax wäre
  $ sed -e '/1,10s/$/:B/p' /etc/passwd

=== Suchtreffer referenzieren ===

.Markiere nur den ersten Suchtreffer mit runden Klammern (Referenz mittels `&`)
----
$ echo "apple orange melon apple Apple" | sed 's/[Aa]pple/(&)/'
(apple) orange melon apple Apple
----

.Markiere jeden Suchtreffer mit runden Klammern (Referenz mittels `&`)
----
$ echo "apple orange melon apple Apple" | sed 's/[Aa]pple/(&)/g'
(apple) orange melon (apple) (Apple)
$
----

.Den ersten und zweiten Suchtreffer in umgekehrter Reihenfolge ausgeben ('back references')
----
$ echo "10247 Berlin" | sed -n 's/\([0-9]\+\) \([A-Za-z]\+\)/\2, \1/p'
Berlin, 10247
$
----

Hinweis: GNU sed kennt die \<ZAHL>-Referenz; BSD sed leider nicht (die Ausgabe is leer, ohne Fehlermeldung).

Zum Grübeln: was erwarten Sie für eine Ausgabe bei?
  $ echo "10247 23 Berlin" | sed -n 's/\([0-9]\+\) \([A-Za-z]\+\)/\2, \1/p'


=== Alle leeren Zeilen aus der Eingabe herausfiltern ===

.Muster `^d` für leere Zeilen, `d` zum Löschen
----
$ sed '/^$/d' logfile-with-empty-lines
2016-01-10 10:45:15 user fho logged in on /dev/tty1
2016-01-11 08:30:10 user fho logged in on /dev/tty2
2016-01-12 08:45:12 user james logged in on /dev/tty1
2016-01-12 08:46:45 user fho logged in on /dev/pty1
2016-01-12 12:13:10 user fho logged out from /dev/pty1
2016-01-12 14:45:12 login failed for user root from 10.10.17.44
2016-01-12 14:46:10 login failed for user root from 10.10.17.45
2016-01-12 14:55:05 user james logged out from /dev/tty1
2016-01-12 14:57:10 login failed for user root from 10.10.17.45
$
----

Hinweis: vergleiche grep -v ^$  logfile-with-empty-lines


=== Den ersten Absatz ausgeben ===

.Alle Zeilen inklusive der ersten Leerzeile ausgeben
----
$ sed -n '1,/^$/p' logfile-with-empty-lines
2016-01-10 10:45:15 user fho logged in on /dev/tty1

$
----

== Weiterführende Dokumente ==

* [[[Barnett]]] Sed - An Introduction and Tutorial by Bruce Barnett, http://www.grymoire.com/Unix/Sed.html
* [[[Dougherty]]] Dale Dougherty: 'sed & awk', O'Reilly, http://shop.oreilly.com/product/9781565922259.do
* [[[Friedl]]] Jeffrey E. F. Friedl: 'Reguläre Ausdrücke', O'Reilly, http://shop.oreilly.com/product/9780596528126.do
* [[[Pement]]] Eric Pement: Useful One-Line Scripts For sed (Unix stream editor), http://sed.sourceforge.net/sed1line.txt
* [[[Wolf]]] Jürgen Wolf: 'Shell-Programmierung. Das umfassende Handbuch', Galileo Computing/Rheinwerk Verlag, ISBN 3-89842-683-1
* [[[Hofmann]]] Frank Hofmann: GitHub-Repo mit ausführlichen Beispielen, https://github.com/hofmannedv/training-shell
